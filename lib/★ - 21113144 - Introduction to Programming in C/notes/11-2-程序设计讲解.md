# \[2023-11-2]程序设计讲解

# 第三次课后作业

## 考察知识点

*   **一维数组、循环、排序**

## 题目详解及出现的问题

## #193.谁是组长

### **Memory Limit Exceeded**：当数组容量特别大时，会超过内存限制

### **maxlongint**：long int 类型的最大值

### **方法一**：**不排序，两层循环遍历数组**

```cpp
#include <stdio.h> 
int main() 
{ 
	int m, i, j, h, sum, flag=0;
	long n, a[10002];    
	scanf("%ld%d",&n,&m); 
	for(i=1;i<=m;i++)
   	scanf("%ld",&a[i]);

	for(i=1; i<=m; i++){
		for(sum=0, j=1; j<=m; j++)   //每轮循环开始时要更新sum的值
      	if( a[i]==a[j] && i!=j )  sum++;
   		if(sum>=m/2) {
			printf("%ld",a[i]);  
			flag=1;  break;  
		} 
 	} 
	if(flag==0) printf("-1"); 
	return 0; 
} 
```

### 方法二：排序，一层循环遍历数组

```cpp
#include <stdio.h>
#include <math.h>

int main() {
	long n, ans = -1;
	int m, i, j;
	scanf("%ld %d", &n, &m);
	long x[m], y;
	for (i = 0; i < m; i++) 
		scanf("%ld", &x[i]);

	if(n==1&&m==1){     //只有一个人的情况
		printf("1");
		return 0;
	}

	for (i = 0; i < m - 1; i++)      //冒泡排序
		for (j = 0; j < m - i - 1; j++) {
			if (x[j] > x[j + 1]) {
				y = x[j], x[j] = x[j + 1], x[j + 1] = y;
			}			
		}

	for (i = 0, j = 0; i < m - 1; i++) {
		if (x[i] == x[i + 1])    //当前元素和下一个元素相等，计数变量+1
			j++;
		else
			j = 0;       //当前元素和下一个元素不相等，计数变量归0
		if (2 * (j + 1) > m) {
			ans = ans + (x[i] + 1);
			break;			
		}
	}
	printf("%ld", ans);

	return 0;
}
```

## #289.数学游戏

### **乘方运算的简洁写法**：pow(x,n)==x^n，函数位于\<math.h>，返回结果为double

```cpp
#include <stdio.h>
#include <math.h>

int main() {
	int i, j1 = 0, j2 = 0, a, b, c, d, e;
	double n, k, x, ans, ans1, ans2, sco1 = 0, sco2 = 0;
	scanf("%lf%lf", &n, &k);
	for (i = 0; i < n; i++) {
		scanf("%d%d%d%d%d%lf", &a, &b, &c, &d, &e, &x);
		scanf("%lf%lf", &ans1, &ans2);
		ans = a * pow(x, 4) + b * pow(x, 3) + c * pow(x, 2) + d * x + e;//乘方运算的简洁写法：pow(x,n)

		if (ans1 == ans) {
			j1++;         //统计连续答对的题目数量
			sco1++;
			if (j1 >= k) {
				sco1 += j1 - k;     //额外加分
			}
		} else {
			j1 = 0;       //答错，连续答对数量置0
		}
		if (ans2 == ans ) {
			j2++;
			sco2++;
			if (j2 >= k) {
				sco2 += j2 - k;
			}
		} else {
			j2 = 0;
		}
	}
	printf("%.0lf %.0lf", sco1, sco2);
	return 0;
}

```

## #653.子序列最大连续和

### 方法一：两层循环，时间复杂度为O(n^2)

*   **可能存在的问题：数据量较大时，需要大量运算时间**

```cpp
#include <stdio.h>

int main() {

       int n, i, j, k, max = -99999, sum = 0;
       scanf("%d", &n);
       int A[n];
       for (i = 0; i < n; i++)
       scanf("%d", &A[i]);

       for (i = 0; i < n; i++)
       for (sum = 0, j = i; j < n; j++) {
       		sum += A[j];
            if (sum > max)  max = sum;
		}

       printf("%d", max);

       return 0;

}
```

### 方法二：动态规划，一层循环，时间复杂度为O(n)

```cpp
#include <stdio.h>

int main() {
	int n;
	scanf("%d", &n);
	int sequence[n];
	for (int i = 0; i < n; i++) {
		scanf("%d", &sequence[i]);
	}

	int maxSum = sequence[0]; // 初始化最大和为序列中的第一个元素
	int currentSum = sequence[0]; // 当前和为序列中的第一个元素

	for (int i = 1; i < n; i++) {
		if (currentSum < 0) {
			// 如果当前和小于0，说明前面的子序列对后面的子序列没有贡献，将当前和重置为当前元素
			currentSum = sequence[i];
		} else {
			// 如果当前和大于等于0，将当前元素加到当前和上
			currentSum += sequence[i];
		}
		if (currentSum > maxSum) {
			// 如果当前和大于最大和，更新最大和
			maxSum = currentSum;
		}
	}

	printf("%d\n", maxSum);

	return 0;
}
```

# 第四次上机

## 考察知识点&#x20;

*   **二维数组、排序、循环、数位运算**

## #128.分数线划定

### 1.排序交换分数的位置时，也要交换学号的位置

### 2.和第k名分数相等的选手也进入面试

```cpp
#include <stdio.h>

int main() {
	int m, n, k, i, j, t;
	int a[5000][2];
	scanf("%d%d", &n, &m);
	for (i = 0; i < n; i++) {
	scanf("%d%d", &a[i][0], &a[i][1]);
	}

	k = m * 1.5;
	for (i = 0; i < n; i++) {
	for (j = 0; j < n - i; j++) {
		if (a[j][1] < a[j + 1][1]) {   //分数不相等，同时交换分数和学号的位置
			t = a[j][1];
			a[j][1] = a[j + 1][1];
			a[j + 1][1] = t;
			t = a[j][0];
			a[j][0] = a[j + 1][0];
			a[j + 1][0] = t;
		}
		if (a[j][1] == a[j + 1][1] && a[j][0] > a[j + 1][0]) {   //分数相等，比较学号
			t = a[j][1];
			a[j][1] = a[j + 1][1];
			a[j + 1][1] = t;
			t = a[j][0];
			a[j][0] = a[j + 1][0];
			a[j + 1][0] = t;
		}
	}
	}

	j = k;
	while (a[j][1] == a[k - 1][1]) {   //和第k名分数相等的选手也进入面试
	j++;
	}
	printf("%d %d\n", a[k - 1][1], j);
	
	for (i = 0; i < j; i++) 
	printf("%d %d\n", a[i][0], a[i][1]);

	return 0;
}
```

## #155.同构数

### 计算x的最后n位数a

```cpp
int a = x % (int) pow(10,n);  //pow函数的返回结果为double，%的操作数为整型
```

### 计算x的位数cnt

```cpp
int cnt = 0;
while(x!=0){
	x/=10;
	cnt++;
}
```

```cpp
#include <stdio.h>
#include <math.h>

int main() {
	int n, m, sum = 0, i, b, c, d, k;
	int a;
	scanf("%d %d", &n, &m);

	for (i = n; i <= m; i++) {
		a = 0;
		k = i;
		do {
			k /= 10;
			a++;
		} while (k != 0);  //求i的位数a

		int res = (i * i - i) % (int)pow(10, a);   // (5776-76) % 10^2 == 0
		if (res == 0)
			sum = sum + i;
	}
	printf ("%d", sum);
	return 0;
}
```

## #186.数字反转（不需要用字符串）

```cpp
#include <stdio.h>
#include <math.h>

int main() {
	long N;
	scanf("%ld", &N);
	long n = 0;
	while (1) {
		int i = N % 10;    //N%10得到个位i
		n = n * 10 + i;
		N = N / 10;
		if (N == 0)
			break;
	}
	printf("%ld", n);
	return 0;
}
```

## 255.矩阵转置

```cpp
#include <stdio.h>

int main() {
	int n = 0, m = 0, o[100][100], a, b;
	scanf("%d %d", &n, &m);
	for (a = 1; a <= n; a++) {
		for (b = 1; b <= m; b++)
			scanf("%d", &o[a][b]);
	}
	for (b = 1; b <= m; b++) {
		for (a = 1; a <= n; a++)
			printf("%d ", o[a][b]);
		printf("\n"); 
	}
	return 0;
}
```

## 456.最大数中的最小

### 创建数组的时候，必须确定数组的容量

### **错误示范：**

```cpp
int n;
int a[n];   //n的值还未确定
scanf("%d",&n);
```

```cpp
#include <stdio.h>

int main() {
	int n, m, i, j, low, x, y;
	scanf("%d%d", &n, &m);
	int mtx[n][m], arr[n], mtt[n] = { 0 }, max = 0;  //arr存放每行的最大值
	for (i = 0; i < n; i++) {
		for (j = 0; j < m; j++) {
			scanf("%d", &mtx[i][j]);
		}
	}

	for (i = 0; i < n; i++) {      //找到每行的最大值
		arr[i] = mtx[i][0];
		for (j = 1; j < m; j++) {
			if (mtx[i][j] > arr[i]) {
				arr[i] = mtx[i][j];
			}
		}
	}

	low = arr[0];
	for (i = 1; i < n; i++) {      //找到最大值中的最小值
		if (low > arr[i]) {
			low = arr[i];
		}
	}
	printf("%d\n", low);
	return 0;
}
```

