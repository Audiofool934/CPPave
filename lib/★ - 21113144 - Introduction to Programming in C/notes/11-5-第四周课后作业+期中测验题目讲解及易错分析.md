# **\[2023-11-9]第四周课后作业+期中测验题目讲解及易错分析**

***

## **第四周考察知识点：数组、字符串、循环**

***

### **110. 回文字符串**

```
易错点分析：
1.对字符数组长度的计算有误，主要出现在for循环的语句条件中
2.在判断回文串时，对临界条件判断有问题

方法一：首尾双指针法
对于数组头尾进行比较时，主要思路可以视为我们用i和j两个变量来对数组中的元素进行遍历比较，其比较终止的条件应该是首位两个指针交错时。
方法二：递归逆转法
对于一个回文串，其正向和反向应该是同样的字符串。我们可以通过一个反转函数，通过递归的方式得到逆转的字符串s‘，比较s和s'是否相等。（同学们也可以关注字符串反转如何实现，这也是常见的字符串题目）

```

#### 方法一：

```c
#include <string.h>

int main() {
	int i, t, s, f = 0;
	char a[1000];
	scanf("%s", &a);
	i = strlen(a);
	for (t = 0; t < i / 2; t++) {
		if (a[t] != a[i - 1 - t])
			f++;
	}
	if (f == 0)
		printf("Yes");
	else
		printf("No");
	return 0;
}
```

#### 方法二：（C++中可以直接调用reverse函数，C语言我们可以通过**函数体实现**调用）

```c
#include <studio.h> 
void Reverse(char *s,int n){
    for(int i=0,j=n-1;i<j;i++,j--){
        char c=s[i];
        s[i]=s[j];
        s[j]=c;
    }
}
int main()
{
    char s[];
    scanf("%c",&s);
    int n = strlen(s);
    Reverse(s,);
    return 0;
}

```

## &#x20;140.数据挖掘

```c
易错点分析：
如何读取字符串中的所需要的内容，如何判断读取已经结束，如何使用strlen函数
EOF是终止符，当读取长度未知的输入时，可以采用
scanf("%s", ch ) == EOF
判读是否读完该字符串
当我们需要得到某一字符串的长度时，我们可以在头函数中加上#include <string.h>
我们就可以使用strlen（s）得到字符数组s的长度
同学对读取“born in”和“major is”目标字符串没有固定思路
思路一：逐个判断字符串
例如读取一个长度为4的字符串，依次判断是否时b,o,r,n
思路二：使用string.h函数strncmp直接对字符串进行比较
使用：strncmp(s1, s2, 3));  //比较s1 s2的前三个字符
```

    #include <stdio.h>
    #include <string.h>

    const int N = 100000;

    int main() {
        int ul = 0;
        char ch[N], ans1[N], ans2[N];
        while (scanf("%s", ch + 1) != EOF) {
            int len = strlen(ch + 1);
            if (len == 4 && ch[1] == 'b' && ch[2] == 'o' && ch[3] == 'r' && ch[4] == 'n') {
                scanf("%s", ch + 1);
                int len1 = strlen(ch + 1);
                if (len1 == 2 && ch[1] == 'i' && ch[2] == 'n')
                    scanf("%s", ans1 + 1);
            } else if (len == 5 && ch[1] == 'm' && ch[2] == 'a' && ch[3] == 'j' && ch[4] == 'o' && ch[5] == 'r') {
                scanf("%s", ch + 1);
                int len1 = strlen(ch + 1);
                if (len1 == 2 && ch[1] == 'i' && ch[2] == 's') {
                    char CH = getchar();
                    CH = getchar();
                    while (CH != '.') {
                        ans2[++ul] = CH;
                        CH = getchar();
                    }
                }
            }
        }

        for (int i = 1; i < strlen(ans1 + 1); ++i)
            putchar(ans1[i]);
        printf(", ");
        for (int i = 1; i <= ul; ++i)
            putchar(ans2[i]);
        puts("");

        return 0;
    }

## 288.字符串之差

    思路一：比较字符串是否相等，可参考140中讲解的两种方法，逐个比较或者采用strncmp函数。
    易错点：同学们在计算ascii码时有时会出错
        char a=0;
        printf("%d",a);//输入想转化为ASCII码的字符，再用整形输出，就能得到输入字符的ASCII码



    #include <stdio.h>
    #include <string.h>

    int stringDifference(char s1[], char s2[]) {
    	int i;
    	// 遍历字符串
    	for (i = 0; s1[i] != '\0' && s2[i] != '\0'; i++) {
    		// 如果当前字符不相等，返回差值
    		if (s1[i] != s2[i]) {
    			return s1[i] - s2[i];
    		}
    	}
    	// 如果两个字符串前面部分相同，返回长度差值
    	return strlen(s1) - strlen(s2);
    }

    int main() {
    	char s1[101], s2[101];
    	gets(s1);
    	gets(s2);

    	int difference = stringDifference(s1, s2);
    	printf("%d\n", difference);

    	return 0;
    }

## 223.获取密码

    易错点：
    如何完成字符串的运算并打印目标字符串，对于运算实际上是对字符顺序的改变，每次打印的实际上是每次新字符串首字符
    方法一：每次先打印，再做运算
    方法二：逐步运算得到目标串，最终再打印

方法一：关键在于每次先==打印首字符==再做运算

```c
#include <stdio.h>
#include <string.h>

int main() {
	char c[10];
	gets(c);
	int tem = 0;
	int n = strlen(c);
	for (int i = 0; i < n; i++) {
		printf("%c", c[0]);
		c[n - i] = c[1];
		for (int j = 0; j < n - i - 1; j++) {
			c[j] = c[j + 2];
		}
	}

	return 0;
}

```

***

```c
#include <stdio.h>
#include <string.h>

int main() {
	char a[100];
	char b[100];
	gets(a);
	int len = strlen(a);
	for (int h = 0; h < len; h++) {
		char tmp = a[1];
		b[h] = a[0];
		for (int j = 0; j < len - 2 - h; j++) {
			a[j] = a[j + 2];
		}
		a[len - 2 - h] = tmp;
		printf("%c", b[h]);
		while (h > len - 1) {
			break;
		}


	}

}
```

## 288.求区间

```typescript
易错点：同学们注意使用合适的整形变量，针对10000000这样的长整形，使用long int类型变量，否则会部分大数字的测试点通过不了
```

#### 方法一：

```c
#include <stdio.h>

int main() {
	long int n, a, b;

	scanf("%ld", &n);

	for (a = 1; a <= n / 2; a++) {
		for (b = a + 1; b <= n / 2 + 1; b++) {
			if ((a + b) * (b - a + 1) / 2 == n) {
				printf("[%ld, %ld]\n", a, b);
			}
			else if((a + b) * (b - a + 1) / 2 > n){
				break;
			}
		}
	}

	return 0;
}
```

## 270.分数约减

    易错点：从数学上是寻找最大公约数，可以直接找到最大公约数后化简输出
    有同学简单枚举素数，这种方法容易遗漏公约数
    也有同学循环时，判断条件有问题，最后一重公约数没有化简，简单一点还是要写循环遍历同时判断余数的方式

方法一：

```c
#include <stdio.h>

int main() {
	int n, m, i, j, k;
	scanf("%d/%d", &n, &m);
	if (n == m) {
		printf("1/1");
	} else if (n > m) {
		for (i = m; i > 1; i--) {
			if (n % i == 0 && m % i == 0) {
				n = n / i;
				m = m / i;
			}
		}
		printf("%d/%d", n, m);

	} else {
		for (i = n; i > 1; i--) {
			if (n % i == 0 && m % i == 0) {
				n = n / i;
				m = m / i;
			}
		}
		printf("%d/%d", n, m);
	}
	return 0;
}

```

## 296.班会时间

    本题主要对二元数组进行统计和排序
    主要思路：
    利用二元组，存储学生的学号和上课时间，存储过程中对浮点数进行分位计数
    计数后对其进行排序，通过循环输出前k个
    易错点：输出时，循环的次数未确定导致只输出一行数据
    对浮点数的处理取余取整操作出现问题
    对题意中的数据类型和存储方法没有梳理清楚

#### 方法一：

```c
#include <stdio.h>

int main() {
	int student[1000][52], b[49][2] ;
	long long int xuehao[1000];
	float y;
	float t;
	int a[7][7], i, j, n, k, l, h;


	scanf("%d%d", &n, &k);
	for (i = 0; i < n; i++) {
		scanf("%d%f", &xuehao[i], &student[i][0]);
		for (j = 1; j < student[i][0] + 1; j++) {
			scanf("%f", &student[i][j]);
			if (student[i][j] != 0) {
				l = (int)student[i][j];
				h = (int)(student[i][j] * 10) % 10;
				a[l - 1][h - 1] += 1;
			}
		}
	}

	for (i = 0; i < 7; i++) {
		for (j = 0; j < 7; j++) {
			b[i * 7 + j][1] = a[i][j];
			b[i * 7 + j][0] = i + 1 + (j + 1) * 0.1 ;
		}
	}
	for (i = 0; i < 48; i++) {
		for (j = 0; j < 48 - i; j++) {
			if (b[j][1] > b[j + 1][1] || b[j][1] == b[j + 1][1] && b[j][0] > b[j + 1][0]) {
				t = b[j][1];
				b[j][1] = b[j + 1][1];
				b[j + 1][1] = t;
				t = b[j][0];
				b[j][0] = b[j + 1][0];
				b[j + 1][0] = t;
			}
		}
	}
	for (i = 0; i < k; i++) {
		printf("%.1f %.0f\n", b[i][0], b[i][1]);
	}
	return 0;
}
```

