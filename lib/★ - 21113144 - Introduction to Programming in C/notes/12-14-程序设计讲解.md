# \[2023-12-12]程序设计讲解

# 第9次课后作业

## 考察知识点

*   **函数、递归**

## 111.Coconuts

### n个椰子分给m个人，整个过程为m+1天

*   **为了防止椰子个数n过大导致超时，从根号n开始查找m**

```cpp
#include <stdio.h>
#include <math.h>
int IsOK(int n, int m) {
	for (int i = 0; i <= m ; i++)
		if ( i==m)					//第m+1天
			if ( n%m==0 ) return 1;
			else return 0;
		else 
			if ( (n-1)%m != 0 ) return 0;
			else n -= (n-1)/m+1;
}

int main() {
	int a[20], m, i, flag;
	for (i = 0; i < 20; i++) {
		scanf("%d", &a[i]);
		if (a[i] == 0)	break;
		flag = 0;
		for (m = sqrt(a[i]); m > 1; m--) 
			if ( IsOK(a[i], m) ) 
				{ printf("%d\n", m);	 flag = 1;	break;	}
		if (flag == 0)	printf("no solution\n");
	}
	return 0;
}
```

## 120.递归算法实现选择排序

*   **选择排序：通过一次扫描，查找数组中的最小元素。然后将最小元素与当前数组中第一个元素交换。对从二个元素开始到最后元素结束的这个子数组重复这个过程**
*   **递归：每次递归调用修改左边界的值，左边界等于右边界时结束递归**
*   **倒序输出：先递归调用再输出，每次输出的是交换的两个元素的序号（交换元素时记录序号）**
*   **交换次数：用静态局部变量（或者全局变量）swap记录，即使函数返回，它的值也会保持不变**

```cpp
#include <stdio.h>
//int swap = 0;			//也可以用全局变量

int qsort(int ary[], int n, int left, int right) {
	int min, i, j, minnum, tmp, seq[n], swapnum[2];
	static int swap = 0;				//用静态局部变量记录交换次数，即使函数返回，它的值也会保持不变
	if (right <= left) return 0;		//左右边界相等，结束递归
	minnum = left;
	min = ary[left];
	for (i = left + 1; i < right; i++)
		if (min > ary[i]) { min = ary[i]; minnum = i; }
	if (ary[minnum] != ary[left]) {
		tmp = ary[minnum]; ary[minnum] = ary[left]; ary[left] = tmp;
		swap += 1;
		swapnum[0] = left;
		swapnum[1] = minnum;		}
	for (i = 0; i < n; i++)
		seq[i] = ary[i];
	qsort(ary, n, left + 1, right);
	if (ary[minnum] != ary[left]) {
		printf("%d<->%d:", swapnum[0] + 1, swapnum[1] + 1);
		for (j = 0; j < right; j++)
			printf("%d ", seq[j]);
		printf("\n");			}
	return swap;
}

int main() {
	int n, array[100], i, swaptime;
	scanf("%d", &n);
	for (i = 0; i < n; i++)
		scanf("%d", &array[i]);
	swaptime = qsort(array, n, 0, n);
	printf("Total steps:%d\n", swaptime);
	printf("Right order:");
	for (i = 0; i < n; i++)
		printf("%d ", array[i]);
	return 0;
}
```

## 163.最大岛屿

## **方法一：不用指针**

### **全局变量sum记录岛屿面积**

```cpp
#include <stdio.h>
#include <math.h>
#include <string.h>

char a[102][102];
int b = 0, num = 0, sum, max = 0;
int n, m;

void search(int x, int y) {
	if (a[x][y] == 'I' && (x >= 0 && x < n) && (y >= 0 && y < m)) {
		sum++;
		a[x][y] = '.';
		search(x - 1, y - 1);
		search(x - 1, y);
		search(x - 1, y + 1);
		search(x, y - 1);
		search(x, y + 1);
		search(x + 1, y - 1);
		search(x + 1, y);
		search(x + 1, y + 1);
	} else
		return;
}

int main() {
	//int n, m;
	scanf("%d %d\n", &n, &m);
	//scanf("\n");//n行m列
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) 
			scanf("%c", &a[i][j]);
		getchar();
	}
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (a[i][j] == 'I') {
				sum = 0;
				num++;
				search(i, j);
				if (sum > max)
					max = sum;
				sum = 0;
			}
		}
	}
	printf("%d %d", num, max);
}
```

## **方法二：指针（通过函数参数传入二维数组）**

### 区分一维数组名、二维数组名、指针、指针数组、数组指针的区别

*   **一维数组名（char a \[] 的a）看作指向数组第一个元素的指针(char\*)**
    ```cpp
    void x(char * a);
    char a[10];
    x(a);
    ```
*   **二维数组名（char a \[] \[]的a）看作一个指向一维数组的指针（char (\* s) \[] ）**
    ```cpp
    void x1(char **a);
    void x2(char *a);
    char a[10][10];

    x1(a);
    //报错：can't convert char (*)[10] to char**

    x2(a);
    //报错：can't convert char (*)[10] to char*
    ```

```cpp
#include <stdio.h>
int island(int *s, int row, int column, char *map[], int rx, int cx);//map是指针数组（数组元素是指针）
int judge(int *s, int row, int column, char *map[], int rx, int cx);
int main(void)
{
    int n, m;
    int sum = 0, max = 0;
    int cnt = 0;
    int temp = 0;
    int *psum = &sum;
    char map[101][101] = {'0'};
    char *mp[101];			//mp是指针数组（数组元素是指针）
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i++)
    {
        scanf("%s", map[i]);
    }
    for (int i = 0; i < n; i++)
    {
        mp[i] = map[i];		//数组mp的每个元素是二维数组map中的每个一维数组
    }

    for (int i = 0; i < n; i++)
    {
        for (int k = 0; k < m; k++)
        {
            if (map[i][k] == 'I')
            {
                temp = island(psum, i, k, mp, n, m);
                max = (max > temp) ? max : temp;
                cnt++;
                *psum = 0;
            }
        }
    }

    printf("%d %d", cnt, max);

    return 0;
}
int island(int *s, int row, int column, char *map[], int rx, int cx)
{
    int t = 0;
    if (judge(s, row, column, map, rx, cx))
    {
        island(s, row - 1, column - 1, map, rx, cx);
        island(s, row - 1, column, map, rx, cx);
        island(s, row - 1, column + 1, map, rx, cx);
        island(s, row, column - 1, map, rx, cx);
        island(s, row, column + 1, map, rx, cx);
        island(s, row + 1, column - 1, map, rx, cx);
        island(s, row + 1, column, map, rx, cx);
        island(s, row + 1, column + 1, map, rx, cx);
    }
    t = *s;

    return t;
}

int judge(int *s, int row, int column, char *map[], int rx, int cx)
{
    if (row >= rx || column >= cx || row < 0 || column < 0)
        return 0;

    if (*(map[row] + column) == 'I')
    {
        (*s)++;
        *(map[row] + column) = '.';
        return 1;
    }
    else
        return 0;
}
```

# 第10次上机

## 考察知识点

*   **递归、数位运算**

## 152.确定进制

### 读入三个整数p、q和 r，然后确定一个进制 B(2<=B<=16) 使得 p \* q = r成立

*   **把p、q、r统一为10进制**
*   **易错点：1 200 200 。虽然用题目描述的运算规则能得到1（2）\*200（2）=200（2），但200不可能是二进制**
*   **把数据转换成十进制的同时，记录该数所有位当中的最大值（比如200所有位的最大值是2），那么200就至少是个三进制数**

```cpp
#include <stdio.h>
#include <math.h>

int to10zhi(int x, int t) {
	int num = 0, i = 0;
	while (x != 0) {
		num = num + x % 10 * pow(t, i);
		i++;
		x = x / 10;
	}
	return num;
}

int maxw(int x) {		//记录该数所有位当中的最大值
	int z = 0;
	while (x != 0) {
		int t = x % 10;
		if (t > z)
			z = t;
		x = x / 10;
	}
	return z;
}

int max(int x, int y) {
	return x > y ? x : y;
}

int main() {
	int n;
	scanf("%d", &n);
	int i, j, k;
	int p[100], q[100], r[100], p1, q1, r1;

	for (i = 0; i < n; i++) {
		scanf("%d%d%d", &p[i], &q[i], &r[i]);
	}

	for (i = 0; i < n; i++) {
		int d = 0;
		//从每个数所有位当中的最大值+1开始，寻找符合题意的进制
		for (j = max(maxw(p[i]), max(maxw(q[i]), maxw(r[i]))) + 1; j <= 16; j++) {
			p1 = to10zhi(p[i], j);
			q1 = to10zhi(q[i], j);
			r1 = to10zhi(r[i], j);
			if (p1 * q1 == r1) {
				printf("%d\n", j);
				d = 1;
				break;
			}
		}
		if (d == 0)
			printf("0\n");
	}

	return 0;
}
```

## 278.爬楼梯

### n 个台阶的楼梯，一次只能爬1个台阶或者2个台阶，求到达顶端的走法数量

*   **递归结束条件：只剩一个台阶时，一种走法；只剩两个台阶时，两种走法**

```cpp
#include <stdio.h>

int ways(int n) {
	if (n == 1)
		return 1;
	else if (n == 2)
		return 2;
	else
		return (ways(n - 1) + ways(n - 2));
}

int main() {
	int n;
	scanf("%d", &n);
	printf("%d", ways(n));
	return 0;
}
```

## 202.分书问题

*   **输入数据100、011、011到9个数组元素：scanf("%1d", \&a\[i]\[j]);**

```cpp
#include <stdio.h>
int n, count = 0;
int Like[10][10], Fangan[10000][10] = {0}, Used[10] = {0}, Take[10];

void Try(int i) {
 if (i==n) {
  for (int j = 0; j < n; j++)
   Fangan[count][j] = Take[j];
  count++;  }
 else
  for (int j = 0; j < n; j++)
   if ((Like[i][j] != 0 ) && (Used[j] != 1)) {
    Take[i] = j;
    Used[j] = 1;
    Try(i + 1); 
    Used[j] = 0;    }
}

void output() {
 if (count == 0)  printf("NO");
 else {
  printf("%d\n", count);
  for (int i = 0; i < count; i++) {
   for (int j = 0; j < n; j++)
    printf("B%d", Fangan[i][j] + 1);
   printf("\n");  }
 }
}

void input() {
 int like_value;
 scanf("%d", &n);
 for (int i = 0; i < n; i++) {
  scanf("%d", &like_value);
  for (int j = 0; j < n; j++) {
   Like[i][n - j - 1] = like_value % 10;
   like_value /= 10;  }
 }
}

int main() {
 input();
 Try(0);
 output();
 return 0;
}
```

## 232.排列问题

*   **按照字典序输出n个小写英字符对应的所有排列**

```cpp
#include <stdio.h>
#include <string.h>

int UseableNum[100], Permu[1000], n, count = 0;
char str[1000];

void Try(int k) {
 if (k == n + 1) {
  count++;
  for (int i = 1; i <= n; ++i)
   printf("%c", Permu[i] + 96);
  printf("\n");
  return;
 }
 for (int i = 1; i <= 26; ++i)
  if (UseableNum[i] > 0) {
   Permu[k] = i;
   UseableNum[i]--;
   Try(k + 1);
   UseableNum[i]++;
  }
}

int main() {
 scanf("%d", &n);
 scanf("%s", &str);

 for (int i = 0; i < n; ++i)
  UseableNum[str[i] - 96]++;

 Try(1);
 printf("%d", count);
 return 0;
}
```

## 117.摘桃子（思路和124.滑雪类似）

*   **在摘得某枝条的桃子之后，小猴子只能选择往左上方爬或者是往右上方爬**
*   **动态规划之最优子结构问题——问题的最优解包含子问题的最优解**
*   **用二维数组taozi记录从（x,y）出发摘得的最多桃子数**

```cpp
#include <stdio.h>
#include <string.h>
int zai(int x, int y);
int a[101][101];
int taozi[101][101];
int zai(int x, int y) {
 int topleft, topright;
 if (taozi[x][y] == -1) 
  if (x==1) taozi[x][y] = a[x][y];
  else if (y==1) taozi[x][y] = a[x][y] + zai(x-1, y);
  else {
   topleft = a[x][y] + zai(x-1, y-1);
   topright = a[x][y] + zai(x-1, y);
   taozi[x][y]= topleft > topright ? topleft : topright; }
 return taozi[x][y];
}

int main() {
 int tier, i, j, max = 0, num;
 scanf("%d", &tier);
 for (i = 1; i <= tier; i++)
  for (j = 1; j <= i; j++) {
   scanf("%d", &a[i][j]);
   taozi[i][j] = -1;  }
 for (j = 1; j <= tier; j++) {
  num = zai(tier, j);
  if (num > max)  max = num; }
 printf("%d", max);

 return 0;
}
```

